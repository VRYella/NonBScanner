"""
Hybrid Motif Detection (Class 9)
Dynamic: generated by overlaps between any two classes; no static subclass list
"""

from .base_motif import wrap, standardize_motif_output


def find_hybrids(motifs, seq, sequence_name: str = "") -> list:
    """Find hybrid motifs where different classes overlap - normalized scoring only"""
    events = []
    for idx, m in enumerate(motifs):
        events.append((m['Start'], 'start', idx))
        events.append((m['End'] + 1, 'end', idx))
    
    events.sort()
    active = set()
    region_start = None
    results = []
    
    for pos, typ, idx in events:
        if typ == 'start':
            active.add(idx)
            if len(active) == 2:
                region_start = pos
        elif typ == 'end':
            if len(active) == 2:
                region_end = pos - 1
                involved_idxs = list(active)
                involved_classes = {motifs[i]['Class'] for i in involved_idxs}
                if len(involved_classes) >= 2:
                    region_motifs = [motifs[i] for i in involved_idxs]
                    
                    # Calculate normalized score based on overlap strength and contributing motifs
                    region_length = region_end - region_start + 1
                    overlap_strength = len(involved_classes) / 8.0  # Normalize by max possible classes (8)
                    length_factor = min(1.0, region_length / 100.0)  # Normalize by typical motif length
                    
                    # Get normalized scores from contributing motifs
                    contributing_norm_scores = []
                    for m in region_motifs:
                        norm_score = m.get('Normalized_Score', m.get('NormScore', 0.0))
                        if norm_score:
                            contributing_norm_scores.append(float(norm_score))
                    
                    # Hybrid normalized score: average of contributing normalized scores * overlap factors
                    if contributing_norm_scores:
                        avg_contrib_score = sum(contributing_norm_scores) / len(contributing_norm_scores)
                        normalized_score = avg_contrib_score * overlap_strength * length_factor
                    else:
                        normalized_score = overlap_strength * length_factor
                    
                    # Ensure normalized score is in [0,1] range
                    normalized_score = max(0.0, min(1.0, normalized_score))
                    
                    subclass = "_".join(sorted(involved_classes)) + "_Overlap"
                    results.append({
                        "Class": "Hybrid",
                        "Subclass": subclass,
                        "Start": region_start,
                        "End": region_end,
                        "Length": region_end - region_start + 1,
                        "MotifClasses": sorted(involved_classes),
                        "ContributingMotifs": region_motifs,
                        "ScoreMethod": "HybridOverlap_normalized",
                        "Normalized_Score": normalized_score,
                        "Sequence": wrap(seq[region_start-1:region_end]),
                    })
            active.discard(idx)
    
    # Standardize output format
    standardized_results = []
    for i, motif in enumerate(results, 1):
        standardized_results.append(standardize_motif_output(motif, sequence_name, i))
    
    return standardized_results


def find_hybrid(motifs, seq: str, sequence_name: str = "") -> list:
    """Main function to find hybrid motifs"""
    return find_hybrids(motifs, seq, sequence_name)