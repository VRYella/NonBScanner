"""
Hybrid Motif Detection (Class 10)
Dynamic: generated by overlaps between any two classes; no static subclass list
"""

import sys
import os

# Add paths for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from motifs.base_motif import wrap, standardize_motif_output
except ImportError:
    def wrap(seq): return seq
    def standardize_motif_output(motif, name, idx): return motif


def find_hybrids(motifs, seq, sequence_name: str = "") -> list:
    """Find hybrid motifs where different classes overlap"""
    events = []
    for idx, m in enumerate(motifs):
        events.append((m['Start'], 'start', idx))
        events.append((m['End'] + 1, 'end', idx))
    
    events.sort()
    active = set()
    region_start = None
    results = []
    
    for pos, typ, idx in events:
        if typ == 'start':
            active.add(idx)
            if len(active) == 2:
                region_start = pos
        elif typ == 'end':
            if len(active) == 2:
                region_end = pos - 1
                involved_idxs = list(active)
                involved_classes = {motifs[i]['Class'] for i in involved_idxs}
                if len(involved_classes) >= 2:
                    region_motifs = [motifs[i] for i in involved_idxs]
                    score = sum(float(m.get("Score", m.get("Actual_Score", 0.0))) for m in region_motifs) * 0.1
                    subclass = "_".join(sorted(involved_classes)) + "_Overlap"
                    results.append({
                        "Class": "Hybrid",
                        "Subclass": subclass,
                        "Start": region_start,
                        "End": region_end,
                        "Length": region_end - region_start + 1,
                        "MotifClasses": sorted(involved_classes),
                        "ContributingMotifs": region_motifs,
                        "ScoreMethod": "HybridOverlap_raw",
                        "Score": float(score),
                        "Sequence": wrap(seq[region_start-1:region_end]),
                    })
            active.discard(idx)
    
    # Standardize output format
    standardized_results = []
    for i, motif in enumerate(results, 1):
        standardized_results.append(standardize_motif_output(motif, sequence_name, i))
    
    return standardized_results


def find_hybrid_motifs(motifs, seq: str, sequence_name: str = "") -> list:
    """Main function to find hybrid motifs - interface for detector registry"""
    return find_hybrids(motifs, seq, sequence_name)


def find_hybrid(motifs, seq: str, sequence_name: str = "") -> list:
    """Alias function for backward compatibility"""
    return find_hybrids(motifs, seq, sequence_name)